\documentclass[11pt]{llncs}
\usepackage{fullpage}

%
\usepackage{latexsym,color}
\usepackage{amscd,amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{pifont}
\usepackage{paralist}
\usepackage{soul}
\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{dashbox}
\usepackage{graphicx}
\usepackage{hyperref}



\title{Notes on Malleable Signatures}

%\date{} % delete this line to display the current date
% \institute{
%IMDEA Software Institute, Madrid, Spain
%\\ \email{\{dario.fiore\}@imdea.org}
%\and
%ENS, CNRS, INRIA, and PSL, Paris, France
%\\ \email{Anca.Nitulescu@ens.fr}
% }

\author{}
\institute{}


\usepackage{color}
\usepackage{notes}
\usepackage{framed}

 \usepackage{a4wide}
 
 \usepackage{enumitem}
\usepackage{amssymb}
  % \setlength{\parskip}{0.1\baselineskip}
\usepackage{multicol}

%
\usepackage[utf8]{inputenc} %
%
\usepackage{amsmath,amssymb,booktabs}


\begin{document}
\maketitle
\input{header}


\subsection{Policy-Based Signatures (Functional Signatures)} %\cite{  Bellare}.

\subsubsection{Policy Checker.} A policy checker
is an NP-relation $PC: \bits^* \times \bits^* \to \bits$. The first input is a
pair $(p, m)$ representing a policy $p \in  \bits^*$ and a message
$m \in  \bits^*$, while the second input is a witness $w \in  \bits^*$.
 The associated language $\L(PC)$ is called the policy language associated to
$PC$. That $(p,m) \in  \L(PC)$ means that signing
$m$ is permitted under policy $p$. We say that
$(p,m,w)$ is $PC$-valid if $PC((p,m),w) = 1$.
\subsubsection{PBS schemes.}
A policy-based signature scheme $\PBS= (\PBSetu, \PBKG, \PBSign, \PBVer)$ is a 4-tupe of  polynomial-time algorithms that work as follows

\begin{itemize}
\item $\PBetup(1^\lambda)$: On input the unary-encoded security parameter
$\lambda$ and outputs a public
parameter $\mpk$ and a master secret key $\msk$.

\item $\PBKG(\msk, p)$: Takes the master secret key $\msk$ and a policy $p \in  \bits^*$ and it outputs a signing key $\sk_p$ for $p$.

\item $\PBSign(\sk_p, m, w)$: Takes as input a message $m \in \bits^*$ and a witness $w \in \bits^*$, the signing key
$\sk_p$ and it outputs a signature $\sigma$  on $m$.

\item $\PBVer(\mpk,  m^*, \sigma)$: Takes as input the public verification key $\mpk$, a message $m^* \in \bits^*$ and a signature $\sigma$, and outputs either $1$ (accept) or $0$ (reject).
\end{itemize}


and satisfy :

\begin{itemize}

\item \textbf{Correctness.} 
\item \textbf{Unforgeablity.}
\item \textbf{Indistinguishability.}
\item \textbf{Simulatability.} 
\item \textbf{Extractability.}
\end{itemize}


\subsection{P-homomorphic Signature Scheme.} %\cite{AhnBonCam2011}.

\subsubsection{Derived Messages}
Let $\M$ be a message space and let $P: 2^{\M} \times \M \to \bits$ be
a predicate from sets over $\M$ and a message in
$\M$ to a bit. We say that a message $m \in \M$
is derivable from the set $M \subseteq \M$ if $P(M,m) = 1$. \\


A P-homomorphic Signature Scheme $\PSig$ for a message space $\M$ and predicate
$P: 2^{\M} \times \M \to \bits$ is a tuple of probabilistic, polynomial-time algorithms
$(\PSetup, \PSign, \Derive, \PVer)$ that work as follows
\begin{itemize}
\item $\PSetup(1^\lambda)$: takes a security parameter $\lambda$ and outputs a 
verification key $\pk$, a secret key $\sk$ and a predicate $P$.
We treat the secret key $\sk$ as a signature on the empty tuple $\epsilon \in \M$.
We also assume that $\pk$ is embedded in $\sk$.


\item $\PSign(\sk, m)$: it outputs a fresh signature $\sigma$ on the message $m \in \M$.

\item $\Derive(\pk, m, \lbrace (\sigma_i, m_i) \rbrace)$: the algorithm takes as input the public key, a set of messages $M= \lbrace m_i \rbrace$ and corresponding signatures $\lbrace \sigma_i \rbrace$, a derived message $m$, and produces a new signature $\sigma_m$ or a special symbol $\perp$ to represent failure. 

\item $\PVer(\pk, m, \sigma_m)$: given a public key, message, and purported signature $\sigma$, the algorithm returns $1$
if the signature is valid and $0$ otherwise.
\end{itemize}

A P-homomorphic Signature Scheme $\PSig$ must satisfy {\em correctness}, {\em unforgeability},  and {\em context hiding}
as described below. 
\begin{itemize}

\item \textbf{Correctness.} 
%We require that for all key pairs $(\sk, \pk)$ generated by $\PSetup(1^\lambda)$
%and for all $M \subset \M$ and
%$m \in \M$ we have:
%\begin{itemize}
%
%\item if $P(M,m) = 1$ then $\Derive(\pk, m, (Sign(\sk,M),M)) \neq \perp$
%\item and
%\end{itemize}



\item \textbf{Unforgeablity.} 
\end{itemize}

\subsubsection{Digital Signature.}
Consider a classical digital signature scheme $\Sigma$ consists of a triple of algorithms  $\Sigma=(\SignKG,\Sign,\SignVer)$ working as follows:
\begin{description}
  \item[$\SignKG(1^{\secpar})$] the key generation takes as input the security parameter $\secpar$ and returns a pair of keys $(\sk',\vk')$.
  \item[$\Sign(\sk', m)$] on input a signing key $\sk$ and a message $m$, the signing algorithm produces 
  a signature $\sigma'$.
  \item[$\SignVer(\vk', m, \sigma')$]  given a triple $\vk',m,\sigma'$ the verification algorithm tests if $\sigma'$ is a valid signature on $m$ with respect to verification key $\vk'$.
\end{description} 


\subsubsection{Construction.}
We construct a P-homomorphic signature scheme starting from $\Sigma$, $\PBS$ and an additionally zero knowledge proof protocol $\ZK$. For this, we need to introduce a labelling to keep track of the delegated keys. The scheme works as follows:\\

\begin{itemize}
\item $\PSetup(1^\lambda)$: Runs $(\msk, \mpk) \gets \PBSetup(1^\lambda)$ and $(\sk', \vk') \gets \SignKG(1^{\secpar})$.  Outputs a verification key $\pk=(\mpk, \vk')$, a secret key $\sk=(\msk, \sk')$ and a predicate $P$
corresponding to a policy $p$.


\item $\PSign(\sk, m, \tau)$: it outputs a fresh signature $\sigma$ on the message $m \in \bits^*$ and an additional signature $\sigma' \gets \Sign(\sk', \tau)$.

\item $\Derive(\pk, \tau, m, \lbrace (\sigma_i, \sigma'_i, m_i) \rbrace)$: Produces a new signature $\sigma_m$ on the derived message $m$ and a $\ZK$ proof $\pi$ on the validity of the signatures $\sigma_i$s and $\sigma'_i$s.

\item $\PVer(\pk, m, \sigma_m, \pi)$: The algorithm runs the $\ZK$-verification on input $\pi$ and the signature verification for $\sigma_m$.

\end{itemize}

 
\bibliographystyle{alpha}
\bibliography{abbrev3,crypto}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
\end{document}